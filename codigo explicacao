#include "stm32g0xx.h"
#include <stdio.h>
#include <stdlib.h>

#define T_DB 8
int deco[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7C, 0x07, 0x7F, 0x6F};

int dado_u = 0, dado_d = 0, dado_c = 0, dado_m = 0;
int qual = 0;
int rx = 0;
int seg=0, hora=0, min=0 ;

void config_serial(void) {
   //configurando serial para 9600bps e interrupção por recepção serial
	RCC->APBENR1 |= 0x20000;//habiliya clock
	GPIOA->MODER |= 0xA0;//habilita func alternativa pa2 e pa3
	GPIOA->AFR[0] = 0x01100;//e eh a funcao alter ativa 1
	USART2->BRR = 1666; ///(16MHz/ 9600)
	//usart_brr= fclock / baudrate
	//usart_brr= 16000000/9600 = 1666

	//receita de bolo
	USART2->CR1 = 0x0000002D;//habilita recep serial
	USART2->CR2 = 0;
	USART2->CR3 = 0;
	//quando tal bit setar faz a interu

	//liga cloclk, conf recp trans, conf usartbrr, e usarttdr-transmit data register, ai fi
	//ca o dado escrito em ouyto usart

	NVIC_SetPriority(USART2_LPUART2_IRQn, 1);//conf prioridade
	NVIC_EnableIRQ(USART2_LPUART2_IRQn);//reuisicao interru
}

void USART2_LPUART2_IRQHandler(void) {
	if (USART2->ISR & 0x20) {//recepcao bit 5
		rx = USART2->RDR;
		//se eu recebi o dado coloca o dado nessa variavel rx
	}
	USART2->ISR &= ~0x20;
	//flag seta q recebi o dado pela porta serial
	//limpa pra refzer interru
}

void manda_serial(int a) {
	while (!((USART2->ISR) & 0x80)) { ;//transmissao outro bit
	//ele fica em 1 enqt ta transmitindo os dados
	//enqt ele ta em 1 ele n recebe nada
	//ent espera ele parar de ficar ocupado pra enviar o dado
	}
	USART2->TDR = a;
	//verifica se o buffer ta recebendo
	//quando o buffer parar eu insiro um novo dado
}

void TIM7_LPTIM2_IRQHandler(void) {
	if (TIM7->SR & 0x01) {
		// Adicione aqui a lógica do TIM7
		TIM7->SR &= ~0x01;
		seg++;
		if(seg>59){
			seg=0;
			if(++min>59){
				min=0;
				if(++hora>23)hora=0;
			}
		}
	}
}

void TIM6_DAC_LPTIM1_IRQHandler(void) {
	if (TIM6->SR & 0x01) {
		GPIOC->ODR |= 0x780;
		GPIOC->ODR &= ~0x7F;

		switch(qual) {
		case 0:
			GPIOC->ODR |= deco[dado_u];
			GPIOC->ODR &= ~0x80;
			qual = 1;
			break;
		case 1:
			GPIOC->ODR |= deco[dado_d];
			GPIOC->ODR &= ~0x100;
			qual = 2;
			break;
		case 2:
			GPIOC->ODR |= deco[dado_c];
			GPIOC->ODR &= ~0x200;
			qual = 3;
			break;
		case 3:
			GPIOC->ODR |= deco[dado_m];
			GPIOC->ODR &= ~0x400;
			qual = 0;
			break;
		}
		TIM6->SR &= ~0x01;
	}
}

//no micro o padrao entrada n ta definiddo, portanto quando tu usa printf naturalmente escreve
//no padrao de saida, mas isso n ta definido no microcontroladoe
int _write(int file, char *ptr, int len) {
   // Implement your write code here, this is used 0by puts and printf for example
   int i = 0;
   for (i = 0; i < len; i++) {
       //lcd_putc((*ptr)); essa e pra usar outro disp
       manda_serial((*ptr));
       ptr++;
   }

   return len;
}

int main(void) {
	int cont=0;
	int seg_ant=0;
	RCC->IOPENR = 0x0000003F;
	GPIOA->MODER = 0x28000400;
	GPIOC->MODER = 0x05555555;
	GPIOB->MODER = 0x00;

	// Configuração TIM7
	RCC->APBENR1 = 0x20;
	TIM7->ARR = 15999;
	TIM7->PSC = 999;
	TIM7->DIER = 0x01;
	TIM7->CR1 = 0x01;

	NVIC_SetPriority(TIM7_LPTIM2_IRQn, 2);
	NVIC_EnableIRQ(TIM7_LPTIM2_IRQn);

	// Configuração TIM6
	RCC->APBENR1 |= 0x10;
	TIM6->ARR = 79;
	TIM6->PSC = 999;
	TIM6->DIER = 0x01;
	TIM6->CR1 = 0x01;

	NVIC_SetPriority(TIM6_DAC_LPTIM1_IRQn, 0);
	NVIC_EnableIRQ(TIM6_DAC_LPTIM1_IRQn);

	config_serial();

	// Inicializa displays com valores
	dado_u = 1;
	dado_d = 2;
	dado_c = 3;
	dado_m = 4;

	while(1) {
		if(rx == 'L') {//se recebeu l
			GPIOA->ODR |= 0x20;//liga led
			rx = 0; // Limpa o caractere processado
			printf("Ligou o LED da placa!\n\r");//manda mensagem dizendo q recebeu
		}
		if(rx == 'D') {//se recebeu d
			GPIOA->ODR &= ~0x20;//desliga led
			rx = 0; // Limpa o caractere processado
			printf("Desligou o LED da placa!\n\r");//avisa
		}

		if(seg_ant!=seg){
			printf("%02i:%02i:%02i\n\r", hora, min, seg);//exibe hora min seg
			seg_ant=seg;//pra passar os seg
		}
	}
}
